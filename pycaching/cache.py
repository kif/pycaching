#!/usr/bin/env python3

import os
import logging
import datetime
import string
import random
from .errors import ValueError
from .point import Point
from .util import Util
try:
    import html2text
    h2t = html2text.HTML2Text()
    h2t.ignore_links = True
except ImportError:
    h2t = None


def lazy_loaded(func):
    """Decorator providing lazy loading."""

    def wrapper(*args, **kwargs):
        self = args[0]
        assert isinstance(self, Cache)
        try:
            return func(*args, **kwargs)
        except AttributeError:
            logging.debug("Lazy loading: %s", func.__name__)
            self.geocaching.load_cache(self.wp, self)
            return func(*args, **kwargs)

    return wrapper


class Cache(object):

    # generated by Util.get_possible_attributes()
    # TODO: smarter way of keeping attributes up to date
    _possible_attributes = {
        "abandonedbuilding": "Abandoned Structure",
        "available": "Available at All Times",
        "bicycles": "Bicycles",
        "boat": "Boat",
        "campfires": "Campfires",
        "camping": "Camping Available",
        "cliff": "Cliff / Falling Rocks",
        "climbing": "Difficult Climbing",
        "cow": "Watch for Livestock",
        "danger": "Dangerous Area",
        "dangerousanimals": "Dangerous Animals",
        "dogs": "Dogs",
        "fee": "Access or Parking Fee",
        "field_puzzle": "Field Puzzle",
        "firstaid": "Needs Maintenance",
        "flashlight": "Flashlight Required",
        "food": "Food Nearby",
        "frontyard": "Front Yard(Private Residence)",
        "fuel": "Fuel Nearby",
        "geotour": "GeoTour Cache",
        "hike_long": "Long Hike (+10km)",
        "hike_med": "Medium Hike (1km-10km)",
        "hike_short": "Short Hike (Less than 1km)",
        "hiking": "Significant Hike",
        "horses": "Horses",
        "hunting": "Hunting",
        "jeeps": "Off-Road Vehicles",
        "kids": "Recommended for Kids",
        "landf": "Lost And Found Tour",
        "mine": "Abandoned Mines",
        "motorcycles": "Motortcycles",
        "night": "Recommended at Night",
        "nightcache": "Night Cache",
        "onehour": "Takes Less Than an Hour",
        "parking": "Parking Available",
        "parkngrab": "Park and Grab",
        "partnership": "Partnership Cache",
        "phone": "Telephone Nearby",
        "picnic": "Picnic Tables Nearby",
        "poisonoak": "Poisonous Plants",
        "public": "Public Transportation",
        "quads": "Quads",
        "rappelling": "Climbing Gear",
        "restrooms": "Public Restrooms Nearby",
        "rv": "Truck Driver/RV",
        "s-tool": "Special Tool Required",
        "scenic": "Scenic View",
        "scuba": "Scuba Gear",
        "seasonal": "Seasonal Access",
        "skiis": "Cross Country Skis",
        "snowmobiles": "Snowmobiles",
        "snowshoes": "Snowshoes",
        "stealth": "Stealth Required",
        "stroller": "Stroller Accessible",
        "swimming": "May Require Swimming",
        "teamwork": "Teamwork Required",
        "thorn": "Thorns",
        "ticks": "Ticks",
        "touristOK": "Tourist Friendly",
        "treeclimbing": "Tree Climbing",
        "UV": "UV Light Required",
        "wading": "May Require Wading",
        "water": "Drinking Water Nearby",
        "wheelchair": "Wheelchair Accessible",
        "winter": "Available During Winter",
        "wirelessbeacon": "Wireless Beacon"
    }

    _possible_types = {
        # key is cache image url, used for parsing: http://www.geocaching.com/images/WptTypes/[KEY].gif
        "2": "Traditional Cache",
        "3": "Multi-cache",
        "8": "Mystery Cache",
        "__8": "Unknown Cache",  # same as Mystery, key not used
        "5": "Letterbox hybrid",
        "6": "Event Cache",
        "mega": "Mega-Event Cache",
        "giga": "Giga-Event Cache",
        "earthcache": "Earthcache",
        "13": "Cache in Trash out Event",
        "11": "Webcam Cache",
        "4": "Virtual Cache",
        "1858": "Wherigo Cache",
        "10Years_32": "Lost and Found Event Cache",
        "ape_32": "Project Ape Cache",
        "HQ_32": "Groundspeak HQ",
        "1304": "GPS Adventures Exhibit",
        "4738": "Groundspeak Block Party",
        "12": "Locationless (Reverse) Cache",
    }

    _possible_sizes = {
        "micro": "micro",
        "small": "small",
        "regular": "regular",
        "large": "large",
        "not_chosen": "not chosen",
        "virtual": "virtual",
        "other": "other",
    }

    CACHE_TYPES_FROM_ID = {
                  2:"Traditional Caches",
                  3:"Multi-caches",
                  4:"Virtual Caches",
                  5:"Letterbox Hybrids",
                  6:"Event Caches",
                  8:"Unknown (Mystery) Caches",
                  9:"Project APE Caches",
                  11:"Webcam Caches",
                  12:"Locationless (Reverse) Caches",
                  13:"Cache In Trash Out Events",
                  137:"Earthcaches",
                  453:"Mega-Event Caches",
                  605:"Geocache Courses",
                  1304:"GPS Adventures Exhibit",
                  1858:"Wherigo Caches",
                  3653:"Lost and Found Event Caches",
                  3773:"Groundspeak HQ",
                  3774:"Groundspeak Lost and Found Celebration",
                  4738:"Groundspeak Block Party",
                  }
    CACHE_TYPES_TO_ID = dict((j.lower().strip("s"),i) for i,j in CACHE_TYPES_FROM_ID.items())

    ATTRIBUTES_FROM_ID = {
                    1: "Dogs",
                    2: "Access or parking fee",
                    3: "Climbing gear",
                    4: "Boat",
                    5: "Scuba gear",
                    6: "Recommended for kids",
                    7: "Takes less than an hour",
                    8: "Scenic view",
                    9: "Significant Hike",
                    10: "Difficult climbing",
                    11: "May require wading",
                    12: "May require swimming",
                    13: "Available at all times",
                    14: "Recommended at night",
                    15: "Available during winter",
                    16: "Cactus",
                    17: "Poison plants",
                    18: "Dangerous Animals",
                    19: "Ticks",
                    20: "Abandoned mines",
                    21: "Cliff / falling rocks",
                    22: "Hunting",
                    23: "Dangerous area",
                    24: "Wheelchair accessible",
                    25: "Parking available",
                    26: "Public transportation",
                    27: "Drinking water nearby",
                    28: "Public restrooms nearby",
                    29: "Telephone nearby",
                    30: "Picnic tables nearby",
                    31: "Camping available",
                    32: "Bicycles",
                    33: "Motorcycles",
                    34: "Quads",
                    35: "Off-road vehicles",
                    36: "Snowmobiles",
                    37: "Horses",
                    38: "Campfires",
                    39: "Thorns",
                    40: "Stealth required",
                    41: "Stroller accessible",
                    42: "Needs maintenance",
                    43: "Watch for livestock",
                    44: "Flashlight required",
                    45: "Lost And Found Tour",
                    46: "Truck Driver/RV",
                    47: "Field Puzzle",
                    48: "UV Light Required",
                    49: "Snowshoes",
                    50: "Cross Country Skis",
                    51: "Special Tool Required",
                    52: "Night Cache",
                    53: "Park and Grab",
                    54: "Abandoned Structure",
                    55: "Short hike (less than 1km)",
                    56: "Medium hike (1km-10km)",
                    57: "Long Hike (+10km)",
                    58: "Fuel Nearby",
                    59: "Food Nearby",
                    60: "Wireless Beacon",
                    61: "Partnership Cache",
                    62: "Seasonal Access",
                    63: "Tourist Friendly",
                    64: "Tree Climbing",
                    65: "Front Yard (Private Residence)",
                    66: "Teamwork Required",
                    }

    ATTRIBUTES_TO_ID = dict((j.lower(),i) for i,j in ATTRIBUTES_FROM_ID.items())

    CONTAINERS_FROM_ID = {
                            1: "Not chosen",
                            2: "Micro",
                            3: "Regular",
                            4: "Large",
                            5: "Virtual",
                            6: "Other",
                            8: "Small",
                    }
    CONTAINERS_TO_ID = dict((j.lower(),i) for i,j in CONTAINERS_FROM_ID.items())

    LOGTYPES_FROM_ID = {  1: "Unarchive",
                  2: "Found it",
                  3: "Didn't find it",
                  4: "Write note",
                  5: "Archive",
                  6: "Archive",
                  7: "Needs Archived",
                  8: "Mark Destroyed",
                  9: "Will Attend",
                  10: "Attended",
                  11: "Webcam Photo Taken",
                  12: "Unarchive",
                  13: "Retrieve It from a Cache",
                  14: "Dropped Off",
                  15: "Transfer",
                  16: "Mark Missing",
                  17: "Recovered",
                  18: "Post Reviewer Note",
                  19: "Grab It (Not from a Cache)",
                  20: "Write Jeep 4x4 Contest Essay",
                  21: "Upload Jeep 4x4 Contest Photo",
                  22: "Temporarily Disable Listing",
                  23: "Enable Listing",
                  24: "Publish Listing",
                  25: "Retract Listing",
                  30: 'Uploaded Goal Photo for "A True Original"',
                  31: 'Uploaded Goal Photo for "Yellow Jeep Wrangler"',
                  32: 'Uploaded Goal Photo for "Construction Site"',
                  33: 'Uploaded Goal Photo for "State Symbol"',
                  34: 'Uploaded Goal Photo for "American Flag"',
                  35: 'Uploaded Goal Photo for "Landmark/Memorial"',
                  36: 'Uploaded Goal Photo for "Camping"',
                  37: 'Uploaded Goal Photo for "Peaks and Valleys"',
                  38: 'Uploaded Goal Photo for "Hiking"',
                  39: 'Uploaded Goal Photo for "Ground Clearance"',
                  40: 'Uploaded Goal Photo for "Water Fording"',
                  41: 'Uploaded Goal Photo for "Traction"',
                  42: 'Uploaded Goal Photo for "Tow Package"',
                  43: 'Uploaded Goal Photo for "Ultimate Makeover"',
                  44: 'Uploaded Goal Photo for "Paint Job"',
                  45: "Needs Maintenance",
                  46: "Owner Maintenance",
                  47: "Update Coordinates",
                  48: "Discovered It",
                  49: 'Uploaded Goal Photo for "Discovery"',
                  50: 'Uploaded Goal Photo for "Freedom"',
                  51: 'Uploaded Goal Photo for "Adventure"',
                  52: 'Uploaded Goal Photo for "Camaraderie"',
                  53: 'Uploaded Goal Photo for "Heritage"',
                  54: "Reviewer Note",
                  55: "Lock User (Ban)",
                  56: "Unlock User (Unban)",
                  57: "Groundspeak Note",
                  58: 'Uploaded Goal Photo for "Fun"',
                  59: 'Uploaded Goal Photo for "Fitness"',
                  60: 'Uploaded Goal Photo for "Fighting Diabetes"',
                  61: 'Uploaded Goal Photo for "American Heritage"',
                  62: 'Uploaded Goal Photo for "No Boundaries"',
                  63: 'Uploaded Goal Photo for "Only in a Jeep"',
                  64: 'Uploaded Goal Photo for "Discover New Places"',
                  65: 'Uploaded Goal Photo for "Definition of Freedom"',
                  66: 'Uploaded Goal Photo for "Adventure Starts Here"',
                  67: "Needs Attention",
                  68: "Post Reviewer Note",
                  69: "Move To Collection",
                  70: "Move To Inventory",
                  71: "Throttle User",
                  72: "Enter CAPTCHA",
                  73: "Change Username",
                  74: "Announcement",
                  75: "Visited",
                }
    LOGTYPES_TO_ID = dict((j.lower(),i) for i,j in LOGTYPES_FROM_ID.items())

    def __init__(self, wp, geocaching, *, name=None, cache_type=None, location=None, state=None,
                 found=None, size=None, difficulty=None, terrain=None, author=None, hidden=None,
                 attributes=None, summary=None, description=None, hint=None, favorites=None, pm_only=None):
        self.wp = wp
        self.geocaching = geocaching
        if name is not None:
            self.name = name
        if cache_type is not None:
            self.cache_type = cache_type
        if location is not None:
            self.location = location
        if state is not None:
            self.state = state
        if found is not None:
            self.found = found
        if size is not None:
            self.size = size
        if difficulty is not None:
            self.difficulty = difficulty
        if terrain is not None:
            self.terrain = terrain
        if author is not None:
            self.author = author
        if hidden is not None:
            self.hidden = hidden
        if attributes is not None:
            self.attributes = attributes
        if summary is not None:
            self.summary = summary
        if description is not None:
            self.description = description
        if hint is not None:
            self.hint = hint
        if favorites is not None:
            self.favorites = favorites
        if pm_only is not None:
            self.pm_only = pm_only

    def __str__(self):
        return self.wp

    def __repr__(self):
        lst = ["%s: %s" % (self.wp, self.name),
             ]
        return os.linesep.join(lst)

    def __eq__(self, other):
        return self.wp == other.wp

    @property
    def wp(self):
        return self._wp

    @wp.setter
    def wp(self, wp):
        wp = str(wp).upper().strip()
        if not wp.startswith("GC"):
            raise ValueError("Waypoint '{}' doesn't start with 'GC'.".format(wp))
        self._wp = wp

    @property
    def geocaching(self):
        return self._geocaching

    @geocaching.setter
    def geocaching(self, geocaching):
        if not hasattr(geocaching, "load_cache"):
            raise ValueError("Passed object (type: '{}') doesn't contain 'load_cache' method.".format(type(geocaching)))
        self._geocaching = geocaching

    @property
    @lazy_loaded
    def name(self):
        return self._name

    @name.setter
    def name(self, name):
        name = str(name).strip()
        self._name = name

    @property
    @lazy_loaded
    def location(self):
        return self._location

    @location.setter
    def location(self, location):
        if type(location) is str:
            location = Point.from_string(location)
        elif type(location) is not Point:
            raise ValueError("Passed object is not Point instance nor string containing coordinates.")
        self._location = location

    @property
    @lazy_loaded
    def cache_type(self):
        return self._cache_type

    @cache_type.setter
    def cache_type(self, cache_type):
        cache_type = cache_type.strip()
        cache_type = cache_type.replace("Geocache", "Cache")
        if cache_type in self._possible_types.values():  # try to search in values
            self._cache_type = cache_type
        elif cache_type in self._possible_types.keys():  # not in values => it must be a key
            self._cache_type = self._possible_types[cache_type]
        else:
            raise ValueError("Cache type '{}' is not possible.".format(cache_type))

    @property
    @lazy_loaded
    def state(self):
        return self._state

    @state.setter
    def state(self, state):
        self._state = bool(state)

    @property
    @lazy_loaded
    def found(self):
        return self._found

    @found.setter
    def found(self, found):
        self._found = bool(found)

    @property
    @lazy_loaded
    def size(self):
        return self._size

    @size.setter
    def size(self, size):
        size = size.strip().lower()
        if size in self._possible_sizes.values():  # try to search in values
            self._size = size
        elif size in self._possible_sizes.keys():  # not in values => it must be a key
            self._size = self._possible_sizes[size]
        else:
            raise ValueError("Size '{}' is not possible.".format(size))

    @property
    @lazy_loaded
    def difficulty(self):
        return self._difficulty

    @difficulty.setter
    def difficulty(self, difficulty):
        difficulty = float(difficulty)
        if difficulty < 1 or difficulty > 5 or difficulty * 10 % 5 != 0:  # X.0 or X.5
            raise ValueError("Difficulty must be from 1 to 5 and divisible by 0.5.")
        self._difficulty = difficulty

    @property
    @lazy_loaded
    def terrain(self):
        return self._terrain

    @terrain.setter
    def terrain(self, terrain):
        terrain = float(terrain)
        if terrain < 1 or terrain > 5 or terrain * 10 % 5 != 0:  # X.0 or X.5
            raise ValueError("Terrain must be from 1 to 5 and divisible by 0.5.")
        self._terrain = terrain

    @property
    @lazy_loaded
    def author(self):
        return self._author

    @author.setter
    def author(self, author):
        author = str(author).strip()
        self._author = author

    @property
    @lazy_loaded
    def hidden(self):
        return self._hidden

    @hidden.setter
    def hidden(self, hidden):
        if type(hidden) is str:
            hidden = Util.parse_date(hidden)
        elif type(hidden) is not datetime.date:
            raise ValueError("Passed object is not datetime.date instance nor string containing date.")
        self._hidden = hidden

    @property
    @lazy_loaded
    def attributes(self):
        return self._attributes

    @attributes.setter
    def attributes(self, attributes):
        if type(attributes) is not dict:
            raise ValueError("Attribues is not dict.")

        self._attributes = {}
        for name, allowed in attributes.items():
            name = name.strip()
            if name in self._possible_attributes:
                self._attributes[name] = allowed
            else:
                logging.warning("Unknown attribute '%s', ignoring.", name)

    @property
    @lazy_loaded
    def summary(self):
        return self._summary

    @summary.setter
    def summary(self, summary):
        summary = str(summary).strip()
        self._summary = summary

    @property
    @lazy_loaded
    def description(self):
        return self._description

    @description.setter
    def description(self, description):
        description = str(description).strip()
        self._description = description

    @property
    @lazy_loaded
    def hint(self):
        return self._hint

    @hint.setter
    def hint(self, hint):
        hint = str(hint).strip()
        self._hint = hint

    @property
    @lazy_loaded
    def favorites(self):
        return self._favorites

    @favorites.setter
    def favorites(self, favorites):
        self._favorites = int(favorites)

    @property
    def pm_only(self):
        return self._pm_only

    @pm_only.setter
    def pm_only(self, pm_only):
        self._pm_only = bool(pm_only)

    def inside_area(self, area):
        """Calculate if geocache is inside given area"""
        return area.inside_area(self.location)

    def to_gpx(self):
        """
        Return the cache description as list of strings representing the XML
        """
        cache_type_id = self.CACHE_TYPES_TO_ID.get(self.cache_type.lower(), 0)
        container_type_id = self.CONTAINERS_TO_ID.get(self.size.lower(), 0)
        author = self.author.replace("&", "&amp;").replace(">","&gt;").replace("<","&lt;")
        name = self.name.replace("&", "&amp;").replace(">","&gt;").replace("<","&lt;")
        randomPR = list(string.ascii_letters+string.digits)
        random.shuffle(randomPR)
        if h2t:
            summary = h2t.handle(self.summary).strip()
            description = h2t.handle(self.description).strip()
        else:
            summary = self.summary.replace("&", "&amp;").replace(">","&gt;").replace("<","&lt;")
            description = self.description.replace("&", "&amp;").replace(">","&gt;").replace("<","&lt;")
        lxml = ['<wpt lat="%.6f" lon="%.6f">'%(self.location.latitude,self.location.longitude),
                '  <time>%sT08:00:00Z</time>'%self.hidden.isoformat(),
                '  <name>%s</name>'%self.wp,
                '  <desc>%s by %s, %s (%.1f/%.1f)</desc>'%(name, author, self.cache_type, self.difficulty, self.terrain),
                '  <url>http://coord.info/%s</url>'%self.wp,
                '  <urlname>%s</urlname>'%name,
                '  <sym>Geocache</sym>',
                '  <type>Geocache|%s</type>'%self.cache_type,
                '  <groundspeak:cache id="%s" available="true" archived="false" memberonly="true" customcoords="true" xmlns:groundspeak="http://www.groundspeak.com/cache/1/0/1">'%(self.wp),
                '    <groundspeak:name>%s</groundspeak:name>'%name,
                '    <groundspeak:placed_by>%s</groundspeak:placed_by>'%author,
                '    <groundspeak:owner id="PR%s">%s</groundspeak:owner>'%("".join(randomPR)[:5],author),
                '    <groundspeak:type id="%s">%s</groundspeak:type>'%(cache_type_id, self.cache_type),
                '    <groundspeak:container id="%s">%s</groundspeak:container>'%(container_type_id, self.size.capitalize()),
                ]
        if self.attributes:
            lxml.append('    <groundspeak:attributes>')
            for attr, val in self.attributes.items():
                interp_attr = self._possible_attributes.get(attr, "")
                ids = self.ATTRIBUTES_TO_ID.get(interp_attr.lower())
                if not ids:
                    ids = self.ATTRIBUTES_TO_ID.get(attr.lower(), 0)
                lxml.append('        <groundspeak:attribute id="%s" inc="%i">%s</groundspeak:attribute>'%(ids, val, interp_attr))
            lxml.append('    </groundspeak:attributes>')
        lxml +=[
                '    <groundspeak:difficulty>%s</groundspeak:difficulty>'%self.difficulty,
                '    <groundspeak:terrain>%s</groundspeak:terrain>'%self.terrain,
                '    <groundspeak:short_description html="%s">%s</groundspeak:short_description>'%("false" if h2t else "true", summary or name),
                '    <groundspeak:long_description html="%s"> %s </groundspeak:long_description>'%("false" if h2t else "true", description),
                '    <groundspeak:encoded_hints>%s</groundspeak:encoded_hints>'%self.hint,
                '  </groundspeak:cache>',
                '</wpt>']
        return lxml
